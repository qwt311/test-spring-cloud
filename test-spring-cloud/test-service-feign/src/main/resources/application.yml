server:
  port: 8765

eureka:
  client:
    registryFetchIntervalSeconds: 300  # 从eureka拉取服务进行更新时间间隔,即检测服务是否正常,默认30 秒一个获取
    instanceInfoReplicationIntervalSeconds: 300  # 检测eureka server 集群中注册服务的变化，如提供方增加了服务从一个变为两个,默认30秒一次检测
    initialInstanceInfoReplicationIntervalSeconds: 40  # 表名最开始将本实例信息复制（即将相关信息注册）到eureka server 需要多长时间
    eurekaServiceUrlPollIntervalSeconds: 300  # 多长时间检测eureka server 集群节点变化,默认300秒
    eurekaServerConnectTimeoutSeconds: 6  # 心跳检测连接到eureka server 的超时时间，同时也是多长时间从连接池中获取连接 默认5秒
    eurekaServerReadTimeoutSeconds: 8  # 心跳检测连接到eureka server ,读取超时时间
    eurekaServerTotalConnections: 200  # 默认连接到所有eureka server 的连接数量，默认200个
    eurekaServerTotalConnectionsPerHost: 50  # 连接到单个eureka server 的数量，默认50个
    service-url:
      defaultZone: http://39.107.44.66:8761/eureka/
  instance:
    prefer-ip-address:  true  # 将自己的ip地址注册到Eureka服务中
    instance-id: ${spring.application.name}:${server.port}:${random.value} #指定实例id
    #参数用于定义服务续约任务的调用间隔时间，默认为30秒
    lease-renewal-interval-in-seconds: 30
    # 参数用于定义服务失效的时间，默认为90秒
    lease-expiration-duration-in-seconds: 90

feign:
  hystrix:
    enabled: true

#重试机制
#该参数用来开启重试机制，默认是开启
spring:
  application:
    name: test-service-feign
  cloud:
    loadbalancer:
      retry:
        enabled: true

#ribbon 的重试设置 Ribbon超时重试次数（总的请求次数）:（MaxAutoRetries+1）*（MaxAutoRetriesNextServer+1）
ribbon:
  ReadTimeout: 300  # 读取超时
  ConnectTimeout: 2000  # 连接超时
  MaxAutoRetries: 1 #同一台实例最大重试次数,不包括首次调用
  MaxAutoRetriesNextServer: 1 #重试负载均衡其他的实例最大重试次数,不包括首次调用,如果还失败就切换下个实例访问
  OkToRetryOnAllOperations: false  #对所有的操作请求都进行重试，如果是get则可以，如果是post,put等操作没有实现幂等的情况下是很危险的，所以设置为false 
  retryableStatusCodes: 404,502  #对指定的响应状态码进行重试 (测试没有被启用)

# eureka服务注册中心名称为 test-eureka-client 的服务单独的超时时间，会覆盖默认的设置
# 设置ribbon的负载均衡策略，需要指明具体的服务
test-eureka-client:
  ribbon:
    # BestAvailableRule : 忽略哪些短路的服务器，并选择并发数较低的服务器
    # AvailabilityFilteringRule: 对以下两种服务器进行忽略：
    #（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。
    # 注意：可以通过修改配置loadbalancer.<clientName>.connectionFailureCountThreshold来修改连接失败多少次之后被设置为短路状态。默认是3次。
    # （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上线，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置
    # ZoneAvoidanceRule:  以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等
    # RandomRule: 随机策略
    # RetryRule: 重试机制的选择逻辑
    # RoundRobinRule: 轮询策略,Ribbon默认的负载均衡规则
    # WeightedResponseTimeRule: 加权策略
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
    ConnectTimeout: 3000 #请求连接超时时间
    ReadTimeout: 1000 #请求处理的超时时间
    OkToRetryOnAllOperations: true #对所有请求都进行重试
    MaxAutoRetriesNextServer: 1 #切换实例的重试次数
    MaxAutoRetries: 1 #对当前实例的重试次数


#如果配置ribbon的重试，hystrix 的超时时间要大于ribbon的超时时间，ribbon才会重试
#hystrix的超时时间=(1 + MaxAutoRetries )*(MaxAutoRetriesNextServer + 1) * (ReadTimeout + ConnectTimeout) 比较好，具体看需求
hystrix:
  command:
    # 也可以针对据具体服务设置，如： 接口服务名称#方法名称(接口参数类型) ,具体下面所示
    #      HiFeignClient#testHi(String):
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 30000
      circuitBreaker:
        # 判断熔断的最少请求数,当在配置时间窗口(metrics.rollingStats.timeInMilliseconds) 内达到此数量后，才会进行熔断与否的判断。默认20个
        requestVolumeThreshold: 1
        # 断路多久以后开始尝试是否恢复，默认5s
        sleepWindowInMilliseconds: 10000
        # 出错百分比阈值，当达到此阈值后，开始短路。默认50%(即失败达到50%及以上时进行熔断)
        errorThresholdPercentage: 50
      metrics:
        rollingStats:
          # 设置窗口滚动的时间，默认10秒
          timeInMilliseconds: 10000
          # 设置统计滚动窗口的桶数量，默认10个桶  必须满足：timeInMilliseconds % numBuckets = 0
          # 存放在每个桶的时间内请求的成功数、失败数、决绝数、超时数
          # 在高并发的环境里，每个桶的时间长度建议大于100ms
          numBuckets: 10
        rollingPercentile:
          # 设置统计滚动百分比窗口的持续时间，用来计算百分比
          timeInMilliseconds: 60000
          # 设置桶的数量，必须满足  timeInMilliseconds % numBuckets = 0
          numBuckets: 6
          # 每个桶内最大容纳的请求数量，默认100个，且只保留最近的100个
          bucketSize: 100
        healthSnapshot:
          # 统计滚动窗口的百分比采样时间
          intervalInMilliseconds: 500

logging:
  level:
    root: debug